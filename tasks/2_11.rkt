#lang sicp

(define (make-interval a b) (cons a b))
(define (lower-bound i) (car i))
(define (upper-bound i) (cdr i))
(define (width i) (- (upper-bound i) (lower-bound i)))

(define (display-interval i)
  (display "(")
  (display (lower-bound i))
  (display ",")
  (display (upper-bound i))
  (display ")")
  (newline))

(define (mul-interval-old x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
	(p2 (* (lower-bound x) (upper-bound y)))
	(p3 (* (upper-bound x) (lower-bound y)))
	(p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
		   (max p1 p2 p3 p4))))

(define (mul-interval-new x y)
  (define (pos x)
    (define (sign x)
      (cond ((> x 0)  1)
	    ((< x 0) -1)
	    (else     0)))
    (if (= (sign (lower-bound x))
	   (sign (upper-bound x)))
	(sign (lower-bound x))
	0))
  (define (commutative-core x y)
    (let ((pos1 (pos x))
	  (pos2 (pos y))
	  (a1   (lower-bound x))
	  (b1   (upper-bound x))
	  (a2   (lower-bound y))
	  (b2   (upper-bound y)))
      (cond ((= pos1 -1)
	     (cond ((= pos2 -1) (make-interval (* b1 b2) (* a1 a2)))
		   ((= pos2  0) (make-interval (* a1 b2) (* a1 a2)))
		   ((= pos2  1) (make-interval (* b1 a2) (* a1 b2)))))
	    ((= pos1  0)
	     (cond ((= pos2  0) (mul-interval-old x y))
		   ((= pos2  1) (make-interval (* a1 b2) (* b1 b2)))))
	    ((= pos1  1)
	     			(make-interval (* a1 a2) (* b1 b2))))))
  (if (> (pos x) (pos y))
      (commutative-core y x)
      (commutative-core x y)))


(define i1 (make-interval  3 5))
(define i2 (make-interval -1 2))

(display-interval (mul-interval-old i1 i2))
(display-interval (mul-interval-new i1 i2))
